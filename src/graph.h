/**
 * Copyright : falcon build system (c) 2014.
 * LICENSE : see accompanying LICENSE file for details.
 */

#ifndef FALCON_GRAPH_H_
# define FALCON_GRAPH_H_

# include <set>
# include <string>
# include <vector>
# include <unordered_map>

/* use for clock and time */
# include <ctime>

# include "cache_manager.h"

/** This file defines the data structure for storing the Graph of Nodes and
 * Rules.
 *
 * - Node: this is either a source file or a target. A Node is generated by only
 *   one Rule (it's child), but can be the input of many rules (it's parents).
 *
 * - Rule: it takes several nodes as input and generates several output nodes.
 *
 * - Graph: this is the data structure that stores the graph of Nodes and
 *   Rules.
 */

namespace falcon {

class Node;
class Rule;
class Graph;
class GraphVisitor;
class WatchmanClient;

typedef std::vector<Node*>                     NodeArray;
typedef std::set<Node*>                        NodeSet;
typedef std::unordered_map<std::string, Node*> NodeMap;
typedef std::vector<Rule*>                     RuleArray;
typedef std::set<Rule*>                        RuleSet;

typedef std::time_t                            Timestamp;

/** Define the state of a node or rule. */
enum class State { UP_TO_DATE, OUT_OF_DATE };

/** Class that represents a node in the graph. */
class Node {
 public:
  explicit Node(const std::string& path, bool isExplicitDependency);

  const std::string& getPath() const;

  /** Return true if this a source file, ie there is no child rule. */
  bool isSource() const;
  Rule* getChild();
  const Rule* getChild() const;

  /**
   * Set a rule to be the child of this node, ie this node is generated by it.
   */
  void setChild(Rule* rule);

  /**
   * Add a rule to be a parent rule of this Node, ie this node is an input of
   * the rule.
   * @param rule Rule to be set as a parent rule.
   */
  void addParentRule(Rule* rule);
  void removeParentRule(Rule* rule);
  bool hasParent(Rule* rule) const;
  RuleArray& getParents();
  const RuleArray& getParents() const;

  bool isExplicitDependency() const;

  /* State management */
  State const& getState() const;
  State& getState();
  bool isDirty() const;
  /* This will restore isLazyFetched_ to false. */
  void setState(State state);

  /**
   * Set the state as Dirty and mark all the parents as dirty too.
   */
  void markDirty();

  Timestamp getTimestamp() const;
  void setTimestamp(Timestamp);

  void setHash(std::string const&);
  std::string const& getHash() const;
  std::string& getHash();

  void setHashDepfile(std::string const&);
  std::string const& getHashDepfile() const;
  std::string& getHashDepfile();

  bool isLazyFetched() const;
  /** Mark the node as lazy fetched. (see isLazyFetched_).
   * Note: any call to setState() that follows will reset isLazyFetched_ to
   * false. */
  void setLazyFetched(bool val);

  /* Operators */
  bool operator==(Node const& n) const;
  bool operator!=(Node const& n) const;

 private:
  std::string path_;

  /* A hash to represent the current state of a Node */
  std::string hash_;

  std::string hashDepfile_;

  /* The rule used to construct this Node.
   * If nullptr, this node is a source file (a leaf node). */
  Rule* childRule_;

  /* The rules that take this node as an input.
  * If empty, this node is a root node because it does not generate any other
  * node. */
  RuleArray parentRules_;

  /* Set to true if this node is an explicit dependency of at least one other
   * node.
   * An explicit dependency is a dependency defined in the graph file, contrary
   * to an implicit dependency which is a dependency discovered at build
   * time. */
  bool isExplicitDependency_;

  /* Set to true if this node was lazy fetched from the cache. This should not
   * be true if the node is out of date.
   * If a node is lazy fetched, this means that some of the nodes that take part
   * in building this node are potentially dirty. */
  bool isLazyFetched_;

  State state_;
  Timestamp timestamp_;

  Node(const Node& other) = delete;
  Node& operator=(const Node&) = delete;
};

/** Class that represents a rule in the graph.
 * A rule is a link between input nodes and output nodes. */
class Rule {
 public:
  /**
   * Construct a rule.
   * @param inputs  Inputs of the rule.
   * @param outputs Outputs of the rule.
   */
  explicit Rule(const NodeArray& inputs, const NodeArray& outputs);

  void addInput(Node* node);
  void addImplicitInput(Node* node);
  unsigned int getNumImplicitInputs() const;
  void setNumImplicitInputs(unsigned int n);
  const NodeArray& getInputs() const;
  NodeArray& getInputs();
  bool isInput(const Node* node) const;

  const NodeArray& getOutputs() const;
  NodeArray& getOutputs();

  bool isPhony() const;
  const std::string& getCommand() const;
  void setCommand(const std::string& cmd);

  const bool hasDepfile() const;
  const std::string& getDepfile() const;
  void setDepfile(const std::string& depfile);

  /* State management */
  State const& getState() const;
  State& getState();
  bool isDirty() const;
  void setState(State state);

  /** Set the state as Dirty and mark all the parents as dirty too. */
  void markDirty();

  void setHash(std::string const&);
  std::string const& getHash() const;
  std::string& getHash();

  void setHashDepfile(std::string const&);
  std::string const& getHashDepfile() const;
  std::string& getHashDepfile();

  Timestamp getTimestamp() const;
  void setTimestamp(Timestamp);

  /** Return True if this rule is ready (ie all its inputs are up to date).
   * This means the rule can safely be built. */
  bool ready() const;
  /** Return the number of inputs that are ready. */
  std::size_t numReady() const;
  /** Increase the counter of ready inputs. */
  void markInputReady();
  /** Decrease the counter of ready inputs. */
  void markInputDirty();

 private:
  /** Targets that need to be built before this rule can be run.
   * The first (inputs_.size() - numImplicitDeps_) elements are the explicit
   * dependencies of the rule, ie the inputs that were explicitly defined in the
   * graph configuration file. The remaining numImplicitDeps_ are implicit
   * dependencies discovered at build time. They are at the end of the array
   * because we always discover them after the explicit dependencies. */
  NodeArray inputs_;

  /** Targets that this rule generates. */
  NodeArray outputs_;

  /** Number of implicit dependencies. The implicit dependencies and at the end
   * of inputs_. */
  unsigned int numImplicitDeps_;

  /** Command to execute in order to generate the outputs. All the inputs must
   * be up-to-date prior to executing the command.
   * Empty string is this is a phony rule. */
  std::string command_;

  /** Path to the file that contains the implicit dependenciess. */
  std::string depfile_;

  /* Set to UP_TO_DATE if all outputs are UP_TO_DATE, OUT_OF_DATE otherwise. */
  State state_;

  /* A hash to represent the current state of a Node. */
  std::string hash_;

  /* A hash that helps for the retrieval of cached depfiles. This hash does not
   * take into account the contents of the inputs that are implicit
   * dependencies. */
  std::string hashDepfile_;

  /* The timestamp of a rule is the last time it was built. */
  Timestamp timestamp_;

  /* Number of inputs that are ready. A ready input is a input that has been
   * built, or a soure file. (Indeed, a source file is always ready, even if it
   * is dirty).
   * This rule can only be run when all the inputs are ready, ie numInputsReady_
   * equals inputs_.size(). */
  std::size_t numInputsReady_;

  Rule(const Rule& other) = delete;
  Rule& operator=(const Rule&) = delete;
};

class GraphParser;

/**
 * Class that stores a graph of nodes and commands.
 */
class Graph {
 public:
  Graph();
  ~Graph();

  void addNode(Node* node);

  const NodeSet& getRoots() const;
  NodeSet& getRoots();

  const NodeSet& getSources() const;
  NodeSet& getSources();

  const NodeMap& getNodes() const;
  NodeMap& getNodes();

  const RuleArray& getRules() const;
  RuleArray& getRules();

 private:

  /* Contains all the root nodes, ie the nodes that are not an input to any
   * Rule. Typically, 'all' is a root node. This is a subset of nodes_. */
  NodeSet roots_;

  /* Contains all the leaf nodes, ie the sources. This is a subset of nodes_. */
  NodeSet sources_;

  /* Contains all the nodes, mapped by their path. */
  NodeMap nodes_;

  /* Contains all the rules */
  RuleArray rules_;

  Graph(const Graph& other) = delete;
  Graph& operator=(const Graph&) = delete;

  friend class GraphParser;
};

} // namespace falcon


/* ************************************************************************* */
/* Tools */

namespace falcon{

/* Check Graph:
 * check if there is a loop in the graph */
void checkGraphLoop(Graph const& g);

/*******************
 * Printer methods *
 *******************/
/* Makefile compatible ouput */
void printGraphMakefile(Graph const&, std::ostream&);
/* Graphviz compatible ouput */
void printGraphGraphviz(Graph const&, std::ostream&);

}

#endif // FALCON_GRAPH_H_
