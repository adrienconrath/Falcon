/**
 * Copyright : falcon build system (c) 2014.
 * LICENSE : see accompanying LICENSE file for details.
 */

#ifndef FALCON_GRAPH_H_
#define FALCON_GRAPH_H_

#include <set>
#include <string>
#include <vector>
#include <unordered_map>

/** This file defines the data structure for storing the Graph of Nodes and
 * Rules.
 *
 * - Node: this is either a source file or a target. A Node is generated by only
 *   one Rule (it's child), but can be the input of many rules (it's parents).
 *
 * - Rule: it takes several nodes as input and generates several output nodes.
 *
 * - Graph: this is the data structure that stores the graph of Nodes and
 *   Rules. It stores a vector of root nodes, ie the nodes that do not generate
 *   any other node, ie the nodes that have no parent.
 */

namespace falcon {

class Node;
class Rule;

typedef std::vector<Node*>                     NodeArray;
typedef std::set<Node*>                        NodeSet;
typedef std::unordered_map<std::string, Node*> NodeMap;
typedef std::vector<Rule*>                     RuleArray;

/** Class that represents a node in the graph. */
class Node {
 public:
  explicit Node(const std::string& path);

  const std::string& getPath() const;

  /**
   * Set a rule to be the child of this node, ie this node is generated by it.
   */
  void setChild(Rule* rule);

  /**
   * Add a rule to be a parent rule of this Node, ie this node is an input of
   * the rule.
   * @param rule Rule to be set as a parent rule.
   */
  void addParentRule(Rule* rule);

 private:
  std::string path_;

  /* The rule used to construct this Node.
   * If nullptr, this node is a source file (a leaf node). */
  Rule* childRule_;

  /* The rules that take this node as an input.
  * If empty, this node is a root node because it does not generate any other
  * node. */
  RuleArray parentRules_;

  Node(const Node& other) = delete;
  Node& operator=(const Node&) = delete;
};

/** Class that represents a rule in the graph.
 * A rule is a link between input nodes and output nodes. */
class Rule {
 public:
  /**
   * Construct a rule.
   * @param inputs  Inputs of the rule.
   * @param outputs Outputs of the rule.
   * @param cmd     Command to be executed in order to generate the outputs.
   */
  explicit Rule(const NodeArray& inputs, const NodeArray& outputs,
                const std::string& cmd);

  /**
   * Construct a phony rule.
   * @param inputs  Inputs of the rule.
   * @param output  Output of the rule. For a phony rule, there is only one
   *                output.
   */
  explicit Rule(const NodeArray& inputs, Node* output);

  const NodeArray& getInputs() const;
  const NodeArray& getOutputs() const;
  bool isPhony() const;
  const std::string& getCommand() const;

 private:
  NodeArray inputs_;
  NodeArray outputs_;

  /* Command to execute in order to generate the outputs. All the inputs must be
   * up-to-date prior to executing the command.
   * Empty string is this is a phony rule. */
  std::string command_;

  /* Set to true if this is a phony rule. A phony rule has no command. */
  bool isPhony_;

  Rule(const Rule& other) = delete;
  Rule& operator=(const Rule&) = delete;
};

/**
 * Class that stores a graph of nodes and commands.
 */
class Graph {
 public:
  Graph(const NodeSet& roots, const NodeMap& nodes);

  const NodeSet& getRoots() const;
  const NodeMap& getNodes() const;

 private:

  /* Contains all the root nodes, ie the nodes that are not an input to any
   * Rule. Typically, 'all' is a root node. */
  NodeSet roots_;

  /* Contains all the nodes, mapped by their path. */
  NodeMap nodes_;

  Graph(const Graph& other) = delete;
  Graph& operator=(const Graph&) = delete;
};

} // namespace falcon

#endif // FALCON_GRAPH_H_
